import brownie
import numpy as np
import pytest
from brownie import ZERO_ADDRESS, Token
from brownie.test import given, strategy
from hypothesis import settings
import numpy as np
from utils.swap_utils import payloadConstructor, LiquidityPayloadConstructor


@pytest.fixture(autouse=True)
def isolation(module_isolation):
    pass


depositValues = [10 * 10**18, 10 * 10**18]


def test_expliot_by_swap(
    accounts,
    crosschaininterface,
    ibcemulator,
    token1,
    token2,
    deploy_swappool,
    fn_isolation,
):
    swappool = deploy_swappool(
        [token1, token2],
        depositValues,
        2**64,
        "PS OneTwoThree",
        "ps(OTT)",
        deployer=accounts[0],
    )

    # We can drain 50% of each pool token or: 1/2 a * 1/2 b = 1/4 a * b
    # 1/4 of one token. So to make this easier, this is what we will do.

    # We do this by sending the max amount of units allowed to the pool. \sum_{0, 1} 1 = 2

    max_num_units = 2 * 2**64 - 1

    hatter = accounts[3]

    fake_payload = payloadConstructor(
        swappool.address,
        swappool.address,
        brownie.convert.to_bytes(hatter.address),
        max_num_units,
        1,
    )
    fake_packet = [["", ""], ["", ""], 0, fake_payload, [0, 0]]

    tx = crosschaininterface.onRecvPacket(fake_packet, {"from": ibcemulator})

    tkn = Token.at(swappool._tokenIndexing(1))

    # a' = 1/4 a = a - delta => delta = 3/4 a.
    # delta / (a') = (3/4 a) / (1 /4 a) = 3

    assert 3 > tkn.balanceOf(hatter) / tkn.balanceOf(swappool) > 3 * 0.9


def test_expliot_too_greedy_by_swap(
    accounts,
    crosschaininterface,
    ibcemulator,
    token1,
    token2,
    deploy_swappool,
    fn_isolation,
):
    swappool = deploy_swappool(
        [token1, token2],
        depositValues,
        2**64,
        "PS OneTwoThree",
        "ps(OTT)",
        deployer=accounts[0],
    )

    max_num_units = 2 * 2**64

    hatter = accounts[3]

    fake_payload = payloadConstructor(
        swappool.address,
        swappool.address,
        brownie.convert.to_bytes(hatter.address),
        max_num_units,
        1,
    )
    fake_packet = [["", ""], ["", ""], 0, fake_payload, [0, 0]]

    with brownie.reverts():
        tx = crosschaininterface.onRecvPacket(fake_packet, {"from": ibcemulator})

    tkn = Token.at(swappool._tokenIndexing(1))
    assert tkn.balanceOf(hatter) == 0


def test_expliot_by_liquidity_swap(
    accounts,
    crosschaininterface,
    ibcemulator,
    token1,
    token2,
    deploy_swappool,
    fn_isolation,
):
    swappool = deploy_swappool(
        [token1, token2],
        depositValues,
        2**64,
        "PS OneTwoThree",
        "ps(OTT)",
        deployer=accounts[0],
    )

    # We can drain 50% of each pool token or: 1/2 a * 1/2 b = 1/4 a * b
    # 1/4 of one token. So to make this easier, this is what we will do.

    # We do this by sending the max amount of units allowed to the pool. \sum_{0, 1} 1 = 2

    max_num_units = int(2 * np.log(3 / 2) / np.log(2) * 2**64) - 1
    # The max is on minted tokens (swappool.totalSupply())
    # For non-amplified pools, this happens to align with the same
    # number of units.
    initialSupply = swappool.totalSupply()

    hatter = accounts[3]

    fake_payload = LiquidityPayloadConstructor(
        swappool.address,
        swappool.address,
        brownie.convert.to_bytes(hatter.address),
        max_num_units,
        1,
        _context=brownie.convert.to_bytes(1, type_str="bytes1"),
    )
    fake_packet = [["", ""], ["", ""], 0, fake_payload, [0, 0]]

    tx = crosschaininterface.onRecvPacket(fake_packet, {"from": ibcemulator})

    assert 1 / 2 > swappool.balanceOf(hatter) / initialSupply > 1 / 2 * 0.9

    swappool.withdrawAll(swappool.balanceOf(hatter), [0, 0, 0], {"from": hatter})

    assert swappool.totalSupply() == initialSupply
    assert 1 / 2 > token1.balanceOf(hatter) / token1.balanceOf(swappool) > 1 / 2 * 0.9
    assert 1 / 2 > token2.balanceOf(hatter) / token2.balanceOf(swappool) > 1 / 2 * 0.9


def test_expliot_too_greedy_by_liquidity_swap(
    accounts,
    crosschaininterface,
    ibcemulator,
    token1,
    token2,
    deploy_swappool,
    fn_isolation,
):
    swappool = deploy_swappool(
        [token1, token2],
        depositValues,
        2**64,
        "PS OneTwoThree",
        "ps(OTT)",
        deployer=accounts[0],
    )

    # We can drain 50% of each pool token or: 1/2 a * 1/2 b = 1/4 a * b
    # 1/4 of one token. So to make this easier, this is what we will do.

    # We do this by sending the max amount of units allowed to the pool. \sum_{0, 1} 1 = 2

    max_num_units = int(2 * np.log(3 / 2) / np.log(2) * 2**64 * 1.01)
    # The max is on minted tokens (swappool.totalSupply())
    # For non-amplified pools, this happens to align with the same
    # number of units.
    initialSupply = swappool.totalSupply()

    hatter = accounts[3]

    fake_payload = payloadConstructor(
        swappool.address,
        swappool.address,
        brownie.convert.to_bytes(hatter.address),
        max_num_units,
        1,
        _context=brownie.convert.to_bytes(1, type_str="bytes1"),
    )
    fake_packet = [["", ""], ["", ""], 0, fake_payload, [0, 0]]

    with brownie.reverts():
        tx = crosschaininterface.onRecvPacket(fake_packet, {"from": ibcemulator})
