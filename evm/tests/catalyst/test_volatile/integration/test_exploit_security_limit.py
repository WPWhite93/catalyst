import pytest
from brownie import convert, reverts

from tests.catalyst.utils.pool_utils import encode_swap_payload


pytestmark = pytest.mark.usefixtures("group_finish_setup", "group_connect_pools")

@pytest.mark.no_call_coverage
def test_exploit_security_limit_with_timeout(
    channel_id,
    pool_1,
    pool_2,
    pool_1_tokens,
    ibc_emulator,
    cross_chain_interface,
    deployer,
    elwood
):
    """
        From the bridge/router perspective: attempt to bypass the security limit by using a timed-out swap:
            1. Extract from the pool as many assets as possible (security limit will allow 1/2 the pool value)
            2. Using those assets, trigger an outgoing swap from the pool that is being attacked to some other pool. In
               general terms, this will cause the unit capacity of the pool to increase.
                => The bridge will have the power to timeout the swap and recover the assets sent
            3. Try to extract more
                => If the unit capacity increase gets updated BEFORE a swap ack is received this exploit will succeed
                => Otherwise, the bridge will be unable of extracting any more assets
    """

    target_token = pool_1_tokens[0]

    # The 'elwood' account will be the one trying to steal the funds
    assert target_token.balanceOf(elwood) == 0

    # Extract half of the pool (reach security limit)
    max_units = pool_1.getUnitCapacity() - 1

    fake_payload = encode_swap_payload(
        pool_2.address,
        pool_1.address,
        convert.to_bytes(elwood.address),
        max_units,
        0,
    )
    fake_packet = [["", channel_id], ["", ""], 0, fake_payload, [0, 0]]     #TODO add helper to build packet
    cross_chain_interface.onRecvPacket(fake_packet, {"from": ibc_emulator})

    # At this point the elwood has extracted 1/2 of the pool
    # ! NOTE: the stolen funds don't necessarily equal the funds left in the pool, as there can be more than
    # ! one token hold by the pool.
    inital_stolen_funds_balance = target_token.balanceOf(elwood)

    # Try to extract more (should fail, as the limit has been reached)
    with reverts():
        fake_payload = encode_swap_payload(
            pool_2.address,
            pool_1.address,
            convert.to_bytes(elwood.address),
            int(0.001 * 10e18),    # Even a very small value of units should fail
            0,
        )
        fake_packet = [["", channel_id], ["", ""], 0, fake_payload, [0, 0]]

        tx = cross_chain_interface.onRecvPacket(fake_packet, {"from": ibc_emulator})

    # Send a cross chain swap with the stolen funds to increase the pool reception capacity (knowing that it will fail)
    target_token.approve(pool_1, inital_stolen_funds_balance, {"from": elwood})
    tx_swap_to_units = pool_1.swapToUnits(
        channel_id,
        convert.to_bytes(pool_2.address),
        convert.to_bytes(deployer.address),
        target_token,
        0,
        inital_stolen_funds_balance,
        0,
        elwood,
        {"from": elwood},
    )

    # Extract more
    max_units = pool_1.getUnitCapacity() - 1

    fake_payload = encode_swap_payload(
        pool_2.address,
        pool_1.address,
        convert.to_bytes(elwood.address),
        max_units,
        0,
    )
    fake_packet = [["", channel_id], ["", ""], 0, fake_payload, [0, 0]]
    cross_chain_interface.onRecvPacket(fake_packet, {"from": ibc_emulator})


    # Times out the swap to recover the initially stolen assets
    ibc_emulator.timeout(
        tx_swap_to_units.events["IncomingMetadata"]["metadata"][0],
        tx_swap_to_units.events["IncomingPacket"]["packet"],
        {"from": deployer},
    )

    # If the balance of 'elwood' exceeds the initial stolen balance it means the security limit was exploited.
    # NOTE: Allow for a small extra margin due to the security limit decay
    assert target_token.balanceOf(elwood) < int(1.001 * inital_stolen_funds_balance), "Pool was exploited"
