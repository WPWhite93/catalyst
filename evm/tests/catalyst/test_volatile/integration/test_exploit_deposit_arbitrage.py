import pytest
from brownie import  convert
from brownie.test import given
from hypothesis.strategies import floats


pytestmark = pytest.mark.usefixtures("group_finish_setup", "group_connect_pools")


@pytest.mark.no_call_coverage
@given(
    deposit_percentage=floats(min_value=0, max_value=2),    # From 0 to 2x the tokens hold by the pool
    arbitrage_amount_percentage=floats(min_value=0, max_value=0.1)  #TODO verify range
)
def test_deposit_into_pool(
    channel_id,
    source_pool,
    source_pool_tokens,
    target_pool,
    target_pool_tokens,
    ibc_emulator,
    berg,
    deployer,
    deposit_percentage,
    arbitrage_amount_percentage
):
    #TODO add test explanation

    # Deposit on source_pool
    deposit_amounts = [int(token.balanceOf(source_pool) * deposit_percentage) for token in source_pool_tokens]

    for token, amount in zip(source_pool_tokens, deposit_amounts):
        token.transfer(berg, amount, {'from': deployer})
        token.approve(source_pool, amount, {'from': berg})
    
    estimated_pool_tokens = int(source_pool.totalSupply()*deposit_percentage)
    
    source_pool.depositMixed(deposit_amounts, int(estimated_pool_tokens*0.999), {"from": berg})


    # test_arbitrage_swap_one_direction
    # Swap target to source
    source_token = source_pool_tokens[0]
    target_token = target_pool_tokens[0]

    arbitrage_amount = int(arbitrage_amount_percentage * target_token.balanceOf(target_pool))

    target_token.transfer(berg, arbitrage_amount, {'from': deployer})
    target_token.approve(target_pool, arbitrage_amount, {'from': berg})

    tx = target_pool.swapToUnits(
        channel_id,
        convert.to_bytes(source_pool.address.replace("0x", "")),
        convert.to_bytes(berg.address.replace("0x", "")),
        target_token,
        0,
        arbitrage_amount,
        0,
        berg,
        {"from": berg},
    )

    ibc_emulator.execute(
        tx.events["IncomingMetadata"]["metadata"][0],
        tx.events["IncomingPacket"]["packet"],
        {"from": berg},
    )

    ackTx = ibc_emulator.ack(tx.events["IncomingMetadata"]["metadata"][0], tx.events["IncomingPacket"]["packet"], {"from": berg})
    assert sum([source_pool._escrowedTokens(token) for token in source_pool_tokens]) == 0

    # test_attempt_withdraw_exploit:
    
    txW = source_pool.withdrawAll(source_pool.balanceOf(berg), [0, 0, 0], {"from": berg})


    # Compute how much we need to swap back.
    y = arbitrage_amount
    a = source_token.balanceOf(source_pool)
    b = target_token.balanceOf(target_pool)
    Wa = source_pool._weight(source_token)
    Wb = target_pool._weight(target_token)
    arb_back_amount = a*(((b - y)/b)**(-Wb/Wa) - 1)
    
    source_token.approve(source_pool, int(arb_back_amount*1.001), {'from': berg})
    
    tx2 = source_pool.swapToUnits(
        channel_id,
        convert.to_bytes(target_pool.address.replace("0x", "")),
        convert.to_bytes(berg.address.replace("0x", "")),
        source_token,
        0,
        int(arb_back_amount*1.001),
        0,
        berg,
        {"from": berg},
    )

    ibc_emulator.execute(
        tx2.events["IncomingMetadata"]["metadata"][0],
        tx2.events["IncomingPacket"]["packet"],
        {"from": berg},
    )

    ackTx = ibc_emulator.ack(tx2.events["IncomingMetadata"]["metadata"][0], tx2.events["IncomingPacket"]["packet"], {"from": berg})

    assert arbitrage_amount <= target_token.balanceOf(berg) <= int(arbitrage_amount*1.001)

    for token, amount in zip(source_pool_tokens, deposit_amounts):
        assert token.balanceOf(berg) <= amount
    