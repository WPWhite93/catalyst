// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.19;

import { ICatalystV1Vault } from "src/ICatalystV1Vault.sol";
import { ICatalystV1VaultEvents } from "src/interfaces/ICatalystV1VaultEvents.sol";
import { VaultNotConnected } from "src/interfaces/ICatalystV1VaultErrors.sol";
import { ICatalystV1Structs } from "src/interfaces/ICatalystV1VaultState.sol";
import { FixedPointMathLib as Math } from "solady/utils/FixedPointMathLib.sol";

import "forge-std/Test.sol";
import { TestCommon } from "test/TestCommon.t.sol";
import { Token } from "test/mocks/token.sol";
import { AVaultInterfaces } from "test/CatalystVault/AVaultInterfaces.t.sol";
import { TestInvariant } from "test/CatalystVault/Invariant.t.sol";


function queryVaultWeightsSum(ICatalystV1Vault vault) returns (uint256) {
    uint256 weightsSum = 0;
    for (uint256 i; true; i++) {
        uint256 weight = vault._weight(vault._tokenIndexing(i));
        if (weight == 0) return weightsSum;
        else weightsSum += weight;
    }
}

abstract contract TestExploitCircumventLiquiditySwapMinOut is TestCommon, AVaultInterfaces {

    bytes32 private constant FEE_RECIPIENT = bytes32(uint256(uint160(0xfee0eec191fa4f)));

    address private constant user = address(1);
    address private constant exploiter = address(2);

    ICatalystV1Vault private fromVault;
    ICatalystV1Vault private toVault;

    function test_CircumventMinOut() external {

        // This exploit demonstrates that the `minimum reference asset` field is required when
        // liquidity swapping to prevent a malicious party from extracting value from the swap
        // by decreasing the value of the pool tokens on the destination vault (i.e. the `minimum
        // vault token output` field is not enough).
        // Assuming the user only specifies a `minimum output` when liquidity swapping, the exploit
        // works by:
        //   1. The malicious party withdraws from the origin vault to make the liquidity swap
        //      consist of more units. This is important, as otherwise the `minimum output` 
        //      protection will cause the user's swap to revert (as the malicious party main 
        //      objective is to decrease the value of the vault tokens of the destination vault).
        //   2. The user executes the liquidity swap.
        //   3. Before the liquidity swap arrives, the malicious party withdraws from the
        //      destination vault.
        //   => When the user's liquidity swap arrives, their vault token return will be worth less
        //      as there will be less assets hold by the vault.

        // Test config
        address[] memory vaults = getTestConfig();
        require(vaults.length >= 2, "Not enough vaults defined");

        // uint8 fromVaultIndex = 0;
        // uint8 toVaultIndex   = 1;

        // address user      = address(1);
        // address exploiter = address(2);

        fromVault = ICatalystV1Vault(vaults[0]);
        toVault   = ICatalystV1Vault(vaults[1]);

        setConnection(address(fromVault), address(toVault), DESTINATION_IDENTIFIER, DESTINATION_IDENTIFIER);

        uint256 swapAmount = Token(address(fromVault)).totalSupply() / 10;
        Token(address(fromVault)).transfer(user, swapAmount);
        vm.deal(user, 1 ether);     // Fund account for incentive payment


        int256 assetReferenceAmount;
        int256 swapReturn;
        {
            // Calculate the expected reference asset amount of the vault tokens being 'bought' on the
            // destination vault
            int256 toVaultTotalSupply   = int256(Token(address(toVault)).totalSupply());
            int256 toVaultWeightSum     = int256(queryVaultWeightsSum(toVault));

            int256 units;
            {
                int256 fromVaultTotalSupply = int256(Token(address(fromVault)).totalSupply());
                int256 fromVaultWeightSum   = int256(queryVaultWeightsSum(fromVault));
                units = Math.lnWad(
                    fromVaultTotalSupply * int256(Math.WAD) / (fromVaultTotalSupply - int256(swapAmount))
                ) * fromVaultWeightSum;
            }
            {
                int256 intermediateWad = Math.expWad(-units/toVaultWeightSum);
                swapReturn = (int256(Math.WAD) - intermediateWad) * toVaultTotalSupply / intermediateWad;
            }
            int256 toVaultWeightedBalancesWad = 0;
            for (uint256 i; true; i++) {
                address token = toVault._tokenIndexing(i);
                if (token == address(0)) break;
                toVaultWeightedBalancesWad += Math.lnWad(int256(
                    Token(token).balanceOf(address(toVault)) * Math.WAD
                )) * int256(toVault._weight(token));
            }

            // Clean up stack significantly.
            toVaultWeightedBalancesWad /= toVaultWeightSum;
            toVaultTotalSupply += swapReturn;
            toVaultTotalSupply *= int256(Math.WAD);

            assetReferenceAmount = Math.expWad(toVaultWeightedBalancesWad) * swapReturn / (toVaultTotalSupply);
        }


        // Action 1: Execute the liquidity swap without performing the exploit (verify the test
        // configuration works)
        uint256 preSwapSnapshot = vm.snapshot();

        vm.recordLogs();
        vm.prank(user);

        ICatalystV1Structs.RouteDescription memory routeDescription = ICatalystV1Structs.RouteDescription({
            chainIdentifier: DESTINATION_IDENTIFIER,
            toVault: convertEVMTo65(address(toVault)),
            toAccount: convertEVMTo65(user),
            incentive: _INCENTIVE,
            deadline: uint64(0)
        });

        uint256 outputUnits = ICatalystV1Vault(fromVault).sendLiquidity{value: _getTotalIncentive(_INCENTIVE)}(
            routeDescription,
            swapAmount,
            [uint256(swapReturn * 999 / 1000), uint256(assetReferenceAmount * 999 / 1000)],
            user,
            hex""
        );
        Vm.Log[] memory entries = vm.getRecordedLogs();
        (, , bytes memory crossChainPacket) = abi.decode(entries[2].data, (bytes32, bytes, bytes));

        // Complete the execution on the destination chain
        (bytes memory _metadata, bytes memory toExecuteMessage) = getVerifiedMessage(address(GARP), crossChainPacket);
        GARP.processPacket(_metadata, toExecuteMessage, FEE_RECIPIENT);

        // Make sure the swap was successful
        uint256 userToVaultTokenBalance = Token(address(toVault)).balanceOf(user);
        assert(userToVaultTokenBalance > 0);

        // Withdraw all the 'received' vault tokens
        vm.prank(user);
        uint256[] memory userWithdrawnTokens = toVault.withdrawAll(
            userToVaultTokenBalance,
            new uint256[](3)
        );




        // Action 2: Run the exploit without setting the `minimum asset reference amount`
        vm.revertTo(preSwapSnapshot);

        uint256 fromVaultExploitAmount = Token(address(fromVault)).totalSupply() / 10;
        uint256 toVaultExploitAmount = fromVaultExploitAmount * 11 / 10;
        Token(address(fromVault)).transfer(exploiter, fromVaultExploitAmount);
        Token(address(toVault)).transfer(exploiter, toVaultExploitAmount);

        // Exploiter withdraws from the source vault right before the user performs the liquidity swap
        vm.prank(exploiter);
        uint256[] memory exploiterFromVaultWithdrawal = fromVault.withdrawAll(fromVaultExploitAmount, new uint256[](3));

        // User performs the liquidity swap
        vm.recordLogs();
        vm.prank(user);
        uint256 outputUnitsDuringExploit = ICatalystV1Vault(fromVault).sendLiquidity{value: _getTotalIncentive(_INCENTIVE)}(
            routeDescription,
            swapAmount,
            [
                uint256(swapReturn * 999 / 1000),
                0   // ! Do not set the `minimum reference asset` amount
            ],
            user,
            hex""
        );
        entries = vm.getRecordedLogs();
        (, , crossChainPacket) = abi.decode(entries[2].data, (bytes32, bytes, bytes));

        // Exploiter withdraws from the destination vault before the swap arrives
        vm.prank(exploiter);
        uint256[] memory exploiterToVaultWithdrawal = toVault.withdrawAll(toVaultExploitAmount, new uint256[](3));

        // Swap arrives at the destination
        (_metadata, toExecuteMessage) = getVerifiedMessage(address(GARP), crossChainPacket);
        vm.recordLogs();
        GARP.processPacket(_metadata, toExecuteMessage, FEE_RECIPIENT);

        // Verify the liquidity swap succeeded (verify ack response)
        entries = vm.getRecordedLogs();
        (, , crossChainPacket) = abi.decode(entries[3].data, (bytes32, bytes, bytes));
        // The mock messaging implementation has 2 initial addresses (32 bytes) before the
        // GeneralisedIncentives payload. Within the GI payload, the Catalyst payload starts on byte 144.
        bytes1 resultId = crossChainPacket[32 + 32 + 144];
        assertEq(resultId, bytes1(0x00));

        // Verify that the user gets a lower return as a result of the exploit

        // The exploiter makes the 'units' sent during the exploit to be more. This is to
        // compensate that once the exploiter withdraws from the destination vault, the same amount
        // of 'units' of a liquidity swap will result in a lower vault token return. By making the
        // swap consist of more 'units', the 'minimum vault token output' specified by the user
        // will still be valid.
        assert(outputUnits < outputUnitsDuringExploit);

        uint256 userToVaultTokenBalanceOnExploit = Token(address(toVault)).balanceOf(user);
        assert(userToVaultTokenBalanceOnExploit > 0);
        vm.prank(user);
        uint256[] memory exploituserWithdrawnTokens = toVault.withdrawAll(userToVaultTokenBalanceOnExploit, new uint256[](3));

        for (uint i; i < userWithdrawnTokens.length; i++) {

            uint256 noExploitWithdrawal = userWithdrawnTokens[i];
            uint256 exploitWithdrawal = exploituserWithdrawnTokens[i];
            if (noExploitWithdrawal == 0 && exploitWithdrawal == 0) {
                continue;
            }
            
            assert(noExploitWithdrawal > exploitWithdrawal);    // Make sure exploit worked
        }




        // Action 3: Run the exploit setting the `minimum asset reference amount`
        vm.revertTo(preSwapSnapshot);

        Token(address(fromVault)).transfer(exploiter, fromVaultExploitAmount);
        Token(address(toVault)).transfer(exploiter, toVaultExploitAmount);

        // Exploiter withdraws from the source vault right before the user performs the liquidity swap
        vm.prank(exploiter);
        exploiterFromVaultWithdrawal = fromVault.withdrawAll(fromVaultExploitAmount, new uint256[](3));



        // User performs the liquidity swap
        vm.recordLogs();
        vm.prank(user);
        outputUnitsDuringExploit = ICatalystV1Vault(fromVault).sendLiquidity{value: _getTotalIncentive(_INCENTIVE)}(
            routeDescription,
            swapAmount,
            [
                uint256(swapReturn * 999 / 1000),
                uint256(assetReferenceAmount * 999 / 1000)  // ! Set the `minimum reference asset`
            ],
            user,
            hex""
        );
        entries = vm.getRecordedLogs();
        (, , crossChainPacket) = abi.decode(entries[2].data, (bytes32, bytes, bytes));

        // Exploiter withdraws from the destination vault before the swap arrives
        vm.prank(exploiter);
        exploiterToVaultWithdrawal = toVault.withdrawAll(toVaultExploitAmount, new uint256[](3));

        // Swap arrives at the destination
        (_metadata, toExecuteMessage) = getVerifiedMessage(address(GARP), crossChainPacket);
        vm.recordLogs();
        GARP.processPacket(_metadata, toExecuteMessage, FEE_RECIPIENT);

        // Verify the liquidity swap failed (verify ack response)
        entries = vm.getRecordedLogs();
        (, , crossChainPacket) = abi.decode(entries[1].data, (bytes32, bytes, bytes));
        // The mock messaging implementation has 2 initial addresses (32 bytes) before the
        // GeneralisedIncentives payload. Within the GI payload, the Catalyst payload starts on byte 144.
        resultId = crossChainPacket[32 + 32 + 144];
        assertEq(resultId, bytes1(0x12));   // 0x12 id corresponds to the 'ReturnInsufficient' error (see CatalystChainInterface.sol)

        userToVaultTokenBalanceOnExploit = Token(address(toVault)).balanceOf(user);
        assert(userToVaultTokenBalanceOnExploit == 0);

    }
}