// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "../../TestCommon.t.sol";
import "src/ICatalystV1Vault.sol";
import "solmate/utils/FixedPointMathLib.sol";
import { ICatalystV1Structs } from "src/interfaces/ICatalystV1VaultState.sol";
import {Token} from "../../mocks/token.sol";
import {AVaultInterfaces} from "../AVaultInterfaces.t.sol";

abstract contract TestSwapWorthlessTokenCrossChain is TestCommon, AVaultInterfaces {
    function test_cross_swap_with_worthless_token(uint56 amount, bytes32 channelId) external {
        address[] memory vaults = getTestConfig();
        require(vaults.length >= 2, "Not enough vaults defined");

        address worthless_token = address(new Token("Worthless", "WTL", 18, 1e6));

        uint8 fromVaultIndex = 0;
        uint8 toVaultIndex = 1;

        address fromVault = vaults[fromVaultIndex];
        address toVault = vaults[toVaultIndex];

        setConnection(fromVault, toVault, channelId, channelId);

        // Send some of the worthless token to the vault to make sure that any calculations that takes
        // into account the current vault asset balance of the token doesn't fail
        Token(worthless_token).transfer(fromVault, 10**18);

        Token(worthless_token).approve(fromVault, amount);

        ICatalystV1Structs.RouteDescription memory routeDescription = ICatalystV1Structs.RouteDescription({
            chainIdentifier: channelId,
            toVault: convertEVMTo65(toVault),
            toAccount: convertEVMTo65(address(this)),
            incentive: _INCENTIVE,
            deadline: uint64(0)
        });

        uint256 unitsBought;
        if (amplified) {
            // For amplified vaults the swap reverts as the swap calculation tries to compute the power of 0.
            // This is not supported by the mathematical library
            vm.expectRevert(bytes("UNDEFINED"));
            unitsBought = ICatalystV1Vault(fromVault).sendAsset{value: _getTotalIncentive(_INCENTIVE)}(
                routeDescription,
                worthless_token,
                0,
                amount,
                0,
                address(this),
                0,
                hex""
            );
        } else {
            unitsBought = ICatalystV1Vault(fromVault).sendAsset{value: _getTotalIncentive(_INCENTIVE)}(
                routeDescription,
                worthless_token,
                0,
                amount,
                0,
                address(this),
                0,
                hex""
            );
        }

        assertEq(
            unitsBought,
            0,
            "pool exploited by buying units with worthless token"
        );
    }
}

