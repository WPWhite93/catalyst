// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "../../TestCommon.t.sol";
import "src/ICatalystV1Vault.sol";
import "src/utils/FixedPointMathLib.sol";
import { ICatalystV1Structs } from "src/interfaces/ICatalystV1VaultState.sol";
import {Token} from "../../mocks/token.sol";
import {AVaultInterfaces} from "../AVaultInterfaces.t.sol";
import { FixedPointMathLib } from "src/utils/FixedPointMathLib.sol";

abstract contract TestEvilRouterExploitVolatile is TestCommon, AVaultInterfaces {
    // This is a test to see if the security limit behaves as intended:
    // That is, no more than 50% of the vault should be extractable.
    function test_extract_value_via_asset_swap() external {
        address toAccount = makeAddr("toAccount"); 
        address[] memory vaults = getTestConfig();
        setUpChains(DESTINATION_IDENTIFIER);

        for (uint256 i = 0; i < vaults.length; ++i) {
            uint256 snapshot = vm.snapshot();
            address vault = vaults[i];
            // set connection between the vault and itself
            ICatalystV1Vault(vault).setConnection(
                DESTINATION_IDENTIFIER,
                convertEVMTo65(vault),
                true
            );

            uint256 target_token_index = 0;
            address target_token = ICatalystV1Vault(vault)._tokenIndexing(target_token_index);

            uint256 initial_target_token_balance = Token(target_token).balanceOf(vault);

            // Get the maximum allowed capacity.
            uint256 units = ICatalystV1Vault(vault).getUnitCapacity();

            bytes memory fake_payload = constructSendAsset(vault, vault, toAccount, units, 0);

            fake_payload = addGARPContext(keccak256(fake_payload), address(CCI), address(CCI), fake_payload);

            fake_payload = addMockContext(fake_payload);

            // Sign the fake payload
            (bytes memory _metadata, bytes memory readyMessage) = getVerifiedMessage(address(GARP), fake_payload);

            // Execute the fake payload
            GARP.processPacket(_metadata, readyMessage, bytes32(abi.encode(address(this))));

            // Get the weight of the target token.
            uint256 weight_of_target_token = ICatalystV1Vault(vault)._weight(target_token);

            uint256 vault_tokens = 1;
            uint256 weightSum = weight_of_target_token;
            while (true) {
                address vault_tkn = ICatalystV1Vault(vault)._tokenIndexing(vault_tokens);
                if (vault_tkn == address(0)) break;
                weightSum += ICatalystV1Vault(vault)._weight(vault_tkn);
                vault_tokens += 1;
            }

            // How much can be extracted is based on which tokens is getting extracted and all associated weights.
            // Say that we have 3 tokens: weight 3, 1, 1 => Weight sum = 5. If we were to extract only token 1,
            // then the proportion would be 5/3 "halves". That is, we can half the balance ≈ 1.67 times.
            // That equates to 1/2**(5/3) = 31.5% of the vault is left or 68.5% of the vault has been extracted.
            // Because of the complexity assocaited, we allow a small error in the margin.

            uint256 extraction_ratio = 10**18 - 10**18 * 10**18 / uint256(FixedPointMathLib.powWad(
                int256(2 * 10**18),
                int256(weightSum * 10**18 / weight_of_target_token)
            ));
            uint256 expected_extraction = initial_target_token_balance * extraction_ratio / 10**18;
            // if more than expected is withdrawn, then it should only be 0.1% more than expected.
            assertGt(Token(target_token).balanceOf(toAccount) * 10000001/10000000, expected_extraction, "Less than expected exploited, even with margin");
            // Likewise, the limit should also be very accurate downwards. We expect some amount to be "exploitable"
            assertLt(Token(target_token).balanceOf(toAccount) * 9999999/10000000, expected_extraction, "More than expected exploited, even with margin");

            vm.revertTo(snapshot);
        }
    }

    function test_error_extract_too_much_via_asset_swap() external {
        address toAccount = makeAddr("toAccount"); 
        address[] memory vaults = getTestConfig();
        setUpChains(DESTINATION_IDENTIFIER);

        for (uint256 i = 0; i < vaults.length; ++i) {
            uint256 snapshot = vm.snapshot();
            address vault = vaults[i];
            // set connection between the vault and itself
            ICatalystV1Vault(vault).setConnection(
                DESTINATION_IDENTIFIER,
                convertEVMTo65(vault),
                true
            );

            uint256 target_token_index = 0;
            address target_token = ICatalystV1Vault(vault)._tokenIndexing(target_token_index);

            uint256 initial_target_token_balance = Token(target_token).balanceOf(vault);

            // Get the maximum allowed capacity.
            uint256 units = ICatalystV1Vault(vault).getUnitCapacity() + 1;

            bytes memory fake_payload = constructSendAsset(vault, vault, toAccount, units, 0);

            fake_payload = addGARPContext(keccak256(fake_payload), address(CCI), address(CCI), fake_payload);

            fake_payload = addMockContext(fake_payload);

            // Sign the fake payload
            (bytes memory _metadata, bytes memory readyMessage) = getVerifiedMessage(address(GARP), fake_payload);

            // Execute the fake payload
            GARP.processPacket(_metadata, readyMessage, bytes32(abi.encode(address(this))));

            // The vault package should revert, thus nothing should be extracted.
            assertEq(Token(target_token).balanceOf(toAccount), 0, "Security limit not working.");

            vm.revertTo(snapshot);
        }
    }

    function test_extract_value_via_liquidity_swap() external {
        address toAccount = makeAddr("toAccount"); 
        address[] memory vaults = getTestConfig();
        setUpChains(DESTINATION_IDENTIFIER);

        for (uint256 i = 0; i < vaults.length; ++i) {
            uint256 snapshot = vm.snapshot();
            address vault = vaults[i];
            // set connection between the vault and itself
            ICatalystV1Vault(vault).setConnection(
                DESTINATION_IDENTIFIER,
                convertEVMTo65(vault),
                true
            );

            uint256 target_token_index = 0;
            address target_token = ICatalystV1Vault(vault)._tokenIndexing(target_token_index);

            uint256 initial_target_token_balance = Token(target_token).balanceOf(vault);

            // Get the maximum allowed capacity.
            uint256 units = ICatalystV1Vault(vault).getUnitCapacity();

            bytes memory fake_payload = constructSendLiquidity(vault, vault, toAccount, units);

            fake_payload = addGARPContext(keccak256(fake_payload), address(CCI), address(CCI), fake_payload);

            fake_payload = addMockContext(fake_payload);

            // Sign the fake payload
            (bytes memory _metadata, bytes memory readyMessage) = getVerifiedMessage(address(GARP), fake_payload);

            // Execute the fake payload
            GARP.processPacket(_metadata, readyMessage, bytes32(abi.encode(address(this))));

            assertGt(Token(vault).balanceOf(toAccount) * 10000001/10000000, Token(vault).totalSupply() / 2, "Less than expected exploited, even with margin");
            assertLt(Token(vault).balanceOf(toAccount) * 9999999/10000000, Token(vault).totalSupply() / 2, "More than expected exploited, even with margin");

            vm.revertTo(snapshot);
        }
    }

    function test_error_extract_too_much_via_liquidity_swap() external {
        address toAccount = makeAddr("toAccount"); 
        address[] memory vaults = getTestConfig();
        setUpChains(DESTINATION_IDENTIFIER);

        for (uint256 i = 0; i < vaults.length; ++i) {
            uint256 snapshot = vm.snapshot();
            address vault = vaults[i];
            // set connection between the vault and itself
            ICatalystV1Vault(vault).setConnection(
                DESTINATION_IDENTIFIER,
                convertEVMTo65(vault),
                true
            );

            uint256 target_token_index = 0;
            address target_token = ICatalystV1Vault(vault)._tokenIndexing(target_token_index);

            uint256 initial_target_token_balance = Token(target_token).balanceOf(vault);

            // Get the maximum allowed capacity.
            uint256 units = ICatalystV1Vault(vault).getUnitCapacity() + 1;

            bytes memory fake_payload = constructSendLiquidity(vault, vault, toAccount, units);

            fake_payload = addGARPContext(keccak256(fake_payload), address(CCI), address(CCI), fake_payload);

            fake_payload = addMockContext(fake_payload);

            // Sign the fake payload
            (bytes memory _metadata, bytes memory readyMessage) = getVerifiedMessage(address(GARP), fake_payload);

            // Execute the fake payload
            GARP.processPacket(_metadata, readyMessage, bytes32(abi.encode(address(this))));

            // The vault package should revert, thus nothing should be extracted.
            assertEq(Token(vault).balanceOf(toAccount), 0, "Security limit not working.");

            vm.revertTo(snapshot);
        }
    }
}

