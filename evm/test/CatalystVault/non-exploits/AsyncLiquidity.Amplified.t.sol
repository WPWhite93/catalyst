// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "../../TestCommon.t.sol";
import "src/ICatalystV1Vault.sol";
import "src/utils/FixedPointMathLib.sol";
import {Token} from "../../mocks/token.sol";
import {AVaultInterfaces} from "../AVaultInterfaces.t.sol";

abstract contract TestAsyncLiquidityAmplified is TestCommon, AVaultInterfaces {

    bytes32 private FEE_RECIPITANT = bytes32(uint256(uint160(0xfee0eec191fa4f)));

    uint256 private constant MARGIN_NUM = 1;
    uint256 private constant MARGIN_DENOM = 1e12;

    function test_no_exploit_execute_async_exploit(uint32 swap_percentage, uint32 deposit_percentage) external {
        address[] memory vaults = getTestConfig();
        require(vaults.length >= 2, "Not enough vaults defined");

        uint256 initial_invariant = invariant(vaults);

        address toAccount = makeAddr("toAccount");

        address vault1 = vaults[0];
        address vault2 = vaults[1];

        setConnection(vault1, vault2, DESTINATION_IDENTIFIER);

        address token1 = ICatalystV1Vault(vault1)._tokenIndexing(0);
        address token2 = ICatalystV1Vault(vault2)._tokenIndexing(0);

        uint256 initial_balance_token1 = Token(token1).balanceOf(vault1);
        uint256 initial_balance_token2 = Token(token2).balanceOf(vault2);

        // Set approvals
        vm.startPrank(toAccount);
        Token(token1).approve(vault1, 2**256-1);
        Token(token2).approve(vault2, 2**256-1);
        vm.stopPrank();

        // Swap 
        uint256 init_swap_amount = Token(vault2).balanceOf(vault2) * uint256(swap_percentage) / type(uint32).max;

        Token(token2).transfer(toAccount, init_swap_amount);
        // Transfer the gas for relaying to the user.
        payable(toAccount).transfer(_getTotalIncentive(_INCENTIVE) * 3);

        {
            // Do an initial sendAsset to imbalance the pool
            ICatalystV1Structs.RouteDescription memory routeDescription = ICatalystV1Structs.RouteDescription({
                chainIdentifier: DESTINATION_IDENTIFIER,
                toVault: convertEVMTo65(vault1),
                toAccount: convertEVMTo65(toAccount),
                incentive: _INCENTIVE
            });

            vm.recordLogs();
            vm.prank(toAccount);
            ICatalystV1Vault(vault2).sendAsset{value: _getTotalIncentive(_INCENTIVE)}(
                routeDescription,
                token2,
                0,
                init_swap_amount,
                0,
                toAccount,
                1,
                hex""
            );
            Vm.Log[] memory entries = vm.getRecordedLogs();

            (, , bytes memory messageWithContext) = abi.decode(entries[1].data, (bytes32, bytes, bytes));

            (bytes memory _metadata, bytes memory toExecuteMessage) = getVerifiedMessage(address(GARP), messageWithContext);

            // Process message
            vm.recordLogs();
            GARP.processPacket(_metadata, toExecuteMessage, FEE_RECIPITANT);

            entries = vm.getRecordedLogs();
            (, , messageWithContext) = abi.decode(entries[3].data, (bytes32, bytes, bytes));

            (_metadata, toExecuteMessage) = getVerifiedMessage(address(GARP), messageWithContext);

            // Process ack
            vm.recordLogs();
            GARP.processPacket(_metadata, toExecuteMessage, FEE_RECIPITANT);
            for (uint256 i = 0; i < 3; ++i) {
                address tkn = ICatalystV1Vault(vault2)._tokenIndexing(i);
                if (tkn == address(0)) break;
                assertEq(ICatalystV1Vault(vault2)._escrowedTokens(tkn), 0, "Ack didn't execute properly");
            }
        }

        // Deposit on vault 1
        uint256[] memory deposit_amounts = new uint256[](3);
        deposit_amounts[0] = Token(token1).balanceOf(vault1) * uint256(deposit_percentage) / type(uint32).max;

        Token(token1).transfer(toAccount, deposit_amounts[0]);
        vm.prank(toAccount);
        ICatalystV1Vault(vault1).depositMixed(deposit_amounts, 0);

        // Swap the rest back to vault 2.
        uint256 swap_back_amount = Token(token1).balanceOf(toAccount);
        {
            ICatalystV1Structs.RouteDescription memory routeDescription = ICatalystV1Structs.RouteDescription({
                chainIdentifier: DESTINATION_IDENTIFIER,
                toVault: convertEVMTo65(vault2),
                toAccount: convertEVMTo65(toAccount),
                incentive: _INCENTIVE
            });

            vm.recordLogs();
            vm.prank(toAccount);
            ICatalystV1Vault(vault1).sendAsset{value: _getTotalIncentive(_INCENTIVE)}(
                routeDescription,
                token1,
                0,
                swap_back_amount,
                0,
                toAccount,
                2,
                hex""
            );
            Vm.Log[] memory entries = vm.getRecordedLogs();

            (, , bytes memory messageWithContext) = abi.decode(entries[1].data, (bytes32, bytes, bytes));

            (bytes memory _metadata, bytes memory toExecuteMessage) = getVerifiedMessage(address(GARP), messageWithContext);

            // Process message
            vm.recordLogs();
            GARP.processPacket(_metadata, toExecuteMessage, FEE_RECIPITANT);

            entries = vm.getRecordedLogs();
            (, , messageWithContext) = abi.decode(entries[3].data, (bytes32, bytes, bytes));

            (_metadata, toExecuteMessage) = getVerifiedMessage(address(GARP), messageWithContext);

            // Process ack
            vm.recordLogs();
            GARP.processPacket(_metadata, toExecuteMessage, FEE_RECIPITANT);
            for (uint256 i = 0; i < 3; ++i) {
                address tkn = ICatalystV1Vault(vault1)._tokenIndexing(i);
                if (tkn == address(0)) break;
                assertEq(ICatalystV1Vault(vault1)._escrowedTokens(tkn), 0, "Ack didn't execute properly");
            }
        }

        uint256[] memory minOuts = new uint256[](3);
        uint256[] memory withdrawWeights = new uint256[](3);
        withdrawWeights[0] = 10**18;

        // Withdraw everything to token 1.
        // if Token(vault1).balanceOf(toAccount) == 0, skip.
        uint256 toAccountBalance = Token(vault1).balanceOf(toAccount);
        if (toAccountBalance > 0) {
            vm.startPrank(toAccount);
            ICatalystV1Vault(vault1).withdrawMixed(
                toAccountBalance,
                withdrawWeights,
                minOuts
            );
            vm.stopPrank();
        }
        
        uint256 swapAmount = 0;
        if (initial_balance_token1 > Token(token1).balanceOf(vault1)) {
            swapAmount = initial_balance_token1 - Token(token1).balanceOf(vault1);
        }
        

        {
            ICatalystV1Structs.RouteDescription memory routeDescription = ICatalystV1Structs.RouteDescription({
                chainIdentifier: DESTINATION_IDENTIFIER,
                toVault: convertEVMTo65(vault2),
                toAccount: convertEVMTo65(toAccount),
                incentive: _INCENTIVE
            });

            vm.recordLogs();
            vm.prank(toAccount);
            ICatalystV1Vault(vault1).sendAsset{value: _getTotalIncentive(_INCENTIVE)}(
                routeDescription,
                token1,
                0,
                swapAmount,
                0,
                toAccount,
                3,
                hex""
            );
            Vm.Log[] memory entries = vm.getRecordedLogs();

            (, , bytes memory messageWithContext) = abi.decode(entries[1].data, (bytes32, bytes, bytes));

            (bytes memory _metadata, bytes memory toExecuteMessage) = getVerifiedMessage(address(GARP), messageWithContext);

            // Process message
            vm.recordLogs();
            GARP.processPacket(_metadata, toExecuteMessage, FEE_RECIPITANT);

            entries = vm.getRecordedLogs();
            (, , messageWithContext) = abi.decode(entries[3].data, (bytes32, bytes, bytes));

            (_metadata, toExecuteMessage) = getVerifiedMessage(address(GARP), messageWithContext);

            // Process ack
            vm.recordLogs();
            GARP.processPacket(_metadata, toExecuteMessage, FEE_RECIPITANT);
            for (uint256 i = 0; i < 3; ++i) {
                address tkn = ICatalystV1Vault(vault1)._tokenIndexing(i);
                if (tkn == address(0)) break;
                assertEq(ICatalystV1Vault(vault1)._escrowedTokens(tkn), 0, "Ack didn't execute properly");
            }
        }


        uint256 end_invariant = invariant(vaults);

        console.logUint(Token(token2).balanceOf(vault2));
        console.logUint(initial_balance_token2);
        console.logUint(Token(token1).balanceOf(vault1));
        console.logUint(initial_balance_token1);
        // check that the both balances are still larger.
        assertGe(Token(token2).balanceOf(vault2) * (MARGIN_DENOM + MARGIN_NUM) / MARGIN_DENOM, initial_balance_token2, "Balance of token2 decreased!");
        assertGe(Token(token1).balanceOf(vault1) * (MARGIN_DENOM + MARGIN_NUM) / MARGIN_DENOM, initial_balance_token1, "Balance of token1 decreased!");

        assertGe(end_invariant * (MARGIN_DENOM + MARGIN_NUM) / MARGIN_DENOM, initial_invariant, "Invariant decreased");
    }
}

