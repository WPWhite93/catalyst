// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.19;

import { ICatalystV1Vault } from "src/ICatalystV1Vault.sol";
import { FixedPointMathLib as Math } from "src/utils/FixedPointMathLib.sol";
import { CatalystVaultAmplified } from "src/CatalystVaultAmplified.sol";

import "forge-std/Test.sol";
import { TestCommon } from "test/TestCommon.t.sol";
import { Token } from "test/mocks/token.sol";
import { AVaultInterfaces } from "test/CatalystVault/AVaultInterfaces.t.sol";
import { TestInvariant } from "test/CatalystVault/Invariant.t.sol";


function queryAssetCount(ICatalystV1Vault vault) returns (uint256) {
    uint256 tokenCount = 0;
    for (uint256 i; true; i++) {
        address token = vault._tokenIndexing(i);
        if (token == address(0)) return tokenCount;
        else tokenCount += 1;
    }
}

function queryVaultBalances(ICatalystV1Vault vault) returns (uint256[] memory) {

    uint256 assetCount = queryAssetCount(vault);

    uint256[] memory balances = new uint256[](assetCount);
    for (uint i; i < assetCount; i++) {
        Token token = Token(vault._tokenIndexing(i));
        balances[i] = token.balanceOf(address(vault));
    }

    return balances;
}


abstract contract TestLargeDepositWithdraw is TestCommon, AVaultInterfaces {

    function test_LargeDepositWithdraw(
        uint32 depositPercentage
    ) external {

        // Verify that depositing and withdrawing cannot be used to extract value from the vault.
        uint256 percentageMultipler = 2;
        // depositPercentage * 2 > type(uint32).max/4 >= 50%
        vm.assume(depositPercentage >= type(uint32).max/4);


        address[] memory vaults = getTestConfig();

        for (uint256 i = 0; i < vaults.length; ++i) {

            CatalystVaultAmplified vault = CatalystVaultAmplified(address(vaults[i]));
            uint256 assetCount = queryAssetCount(vault);
            uint256[] memory initialBalances = queryVaultBalances(vault);

            address user = address(1);

            uint256 initialBalance0 = vault.computeBalance0();
            uint256 initialVaultTokenValue = initialBalance0 / Token(address(vault)).totalSupply();

            // Throughout the test, the 'vault token value' shouldn't decrease.


            // Perform the deposit (deposit the token at index 0)
            Token depositedToken = Token(vault._tokenIndexing(0));
            uint256 depositAmount = initialBalances[0] * depositPercentage * percentageMultipler / type(uint32).max;

            depositedToken.transfer(user, depositAmount);
            vm.prank(user);
            depositedToken.approve(address(vault), depositAmount);

            uint256[] memory tokenAmounts = new uint256[](assetCount);
            tokenAmounts[0] = depositAmount;

            vm.prank(user);
            uint256 userVaultTokens = vault.depositMixed(
                tokenAmounts,
                0   // Min out
            );

            // Verify the balance0 / vault token value
            assert(
                vault.computeBalance0() > initialBalance0   // 'balance0' increases on deposits
            );
            assert(
                vault.computeBalance0() / Token(address(vault)).totalSupply() >= initialVaultTokenValue
            );


            uint256 preWithdrawSnapshot = vm.snapshot();



            // Tested action 1: withdraw all

            vault.withdrawAll(
                userVaultTokens,
                new uint256[](assetCount)       // Set 'min out' to 0
            );

            // Verify the vault token value
            assert(
                vault.computeBalance0() / Token(address(vault)).totalSupply()
                    >= initialVaultTokenValue * 9999999999/10000000000  // Allow for a very small margin of error
            );

            // Swap all of the withdrawn tokens for the deposited token (simulate withdrawing a single token)
            for (uint j = 1; j < assetCount; j++) {
                Token token = Token(vault._tokenIndexing(j));
                uint256 swapAmount = token.balanceOf(user);

                vm.prank(user);
                token.approve(address(vault), swapAmount);

                vm.prank(user);
                vault.localSwap(address(token), address(depositedToken), swapAmount, 0);
            }

            // Verify the vault token value
            assert(
                vault.computeBalance0() / Token(address(vault)).totalSupply()
                    >= initialVaultTokenValue * 9999999999/10000000000  // Allow for a very small margin of error
            );

            // The user should not have been able to withdraw any more than originally deposited.
            assert(
                depositedToken.balanceOf(user) <= depositAmount
            );



            // Tested action 2: withdraw mixed
            vm.revertTo(preWithdrawSnapshot);

            uint256[] memory withdrawRatio = new uint256[](assetCount);
            withdrawRatio[0] = Math.WAD;        // Set the withdraw ratio to [1, 0, 0]
            vault.withdrawMixed(
                userVaultTokens,
                withdrawRatio,
                new uint256[](assetCount)       // Set 'min out' to 0
            );

            // Verify the vault token value
            assert(
                vault.computeBalance0() / Token(address(vault)).totalSupply()
                    >= initialVaultTokenValue * 9999999999/10000000000  // Allow for a very small margin of error
            );

            // The user should not have been able to withdraw any more than originally deposited.
            assert(
                depositedToken.balanceOf(user) <= depositAmount
            );
            
        }

    }

}