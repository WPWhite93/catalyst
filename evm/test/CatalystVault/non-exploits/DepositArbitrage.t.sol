// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "../../TestCommon.t.sol";
import "src/ICatalystV1Vault.sol";
import "solady/utils/FixedPointMathLib.sol";
import { ICatalystV1Structs } from "src/interfaces/ICatalystV1VaultState.sol";
import {Token} from "../../mocks/token.sol";
import {AVaultInterfaces} from "../AVaultInterfaces.t.sol";
import { FixedPointMathLib } from "solady/utils/FixedPointMathLib.sol";
import { CatalystVaultAmplified } from "src/CatalystVaultAmplified.sol";

abstract contract TestDepositArbitrageExploit is TestCommon, AVaultInterfaces {

    bytes32 private FEE_RECIPITANT = bytes32(uint256(uint160(0xfee0eec191fa4f)));

    uint256 private constant MARGIN_NUM = 1;
    uint256 private constant MARGIN_DENOM = 1e12;

    /**
     * This test ensures that the deposit and withdrawal methods cannot
     * be exploited to return more to the user. However, it actually
     * proves it can be done. But it check that the exploit returns less than 0,035% extra. 
     */
    function test_arbitrage_swap_exploit(uint32 deposit_percentage, uint32 arbitrage_amount_percentage) external {
        vm.assume(arbitrage_amount_percentage > 10);
        address toAccount = makeAddr("toAccount"); 
        address[] memory vaults = getTestConfig();

        address vault1 = vaults[0];
        address vault2 = vaults[1];

        uint256 start_invariant = invariant(vaults);

        setConnection(vault1, vault2, DESTINATION_IDENTIFIER);

        uint256[] memory deposit_amounts = new uint256[](3);
        for (uint256 i = 0; i < 3; ++i) {
            address tkn = ICatalystV1Vault(vault1)._tokenIndexing(i);
            if (tkn == address(0)) break;
            deposit_amounts[i] = Token(tkn).balanceOf(vault1) * deposit_percentage / type(uint32).max;
            Token(tkn).transfer(toAccount, deposit_amounts[i]);
            vm.startPrank(toAccount);
            Token(tkn).approve(vault1, deposit_amounts[i]);
            Token(tkn).balanceOf(toAccount);
            vm.stopPrank();
        }
        payable(toAccount).transfer(10**18*100);

        vm.prank(toAccount);
        uint256 vault_tokens = ICatalystV1Vault(vault1).depositMixed(deposit_amounts, 0);

        // test_arbitrage_swap_one_direction
        // Swap vault1 to vault2
        address source_token = ICatalystV1Vault(vault1)._tokenIndexing(0);
        address target_token = ICatalystV1Vault(vault2)._tokenIndexing(0);

        // Max is 10%, so we divide by 10
        uint256 arbitrage_amount = Token(target_token).balanceOf(vault2) * arbitrage_amount_percentage / type(uint32).max / 10;

        Token(target_token).transfer(toAccount, arbitrage_amount);
        vm.prank(toAccount);
        Token(target_token).approve(vault2, arbitrage_amount);

        ICatalystV1Structs.RouteDescription memory routeDescription = ICatalystV1Structs.RouteDescription({
            chainIdentifier: DESTINATION_IDENTIFIER,
            toVault: convertEVMTo65(vault1),
            toAccount: convertEVMTo65(toAccount),
            incentive: _INCENTIVE,
            deadline: uint64(0)
        });

        vm.recordLogs();
        vm.prank(toAccount);
        ICatalystV1Vault(vault2).sendAsset{value: _getTotalIncentive(_INCENTIVE)}(
            routeDescription,
            target_token,
            0,
            arbitrage_amount,
            0,
            toAccount,
            0,
            hex""
        );
        Vm.Log[] memory entries = vm.getRecordedLogs();

        (, , bytes memory messageWithContext) = abi.decode(entries[1].data, (bytes32, bytes, bytes));

        (bytes memory _metadata, bytes memory toExecuteMessage) = getVerifiedMessage(address(GARP), messageWithContext);

        // Process message
        vm.recordLogs();
        GARP.processPacket(_metadata, toExecuteMessage, FEE_RECIPITANT);

        entries = vm.getRecordedLogs();
        (, , messageWithContext) = abi.decode(entries[3].data, (bytes32, bytes, bytes));

        (_metadata, toExecuteMessage) = getVerifiedMessage(address(GARP), messageWithContext);

        // Process ack
        vm.recordLogs();
        GARP.processPacket(_metadata, toExecuteMessage, FEE_RECIPITANT);
        for (uint256 i = 0; i < 3; ++i) {
            address tkn = ICatalystV1Vault(vault2)._tokenIndexing(i);
            if (tkn == address(0)) break;
            assertEq(ICatalystV1Vault(vault2)._escrowedTokens(tkn), 0, "Ack didn't execute properly");
        }

        uint256[] memory minOuts = new uint256[](3);

        // test_attempt_withdraw_exploit:
        vm.startPrank(toAccount);
        ICatalystV1Vault(vault1).withdrawAll(vault_tokens, minOuts);
        vm.stopPrank();

        // Compute how much we need to swap back.
        uint256 a = Token(source_token).balanceOf(vault1);
        uint256 b = Token(target_token).balanceOf(vault2);
        uint256 y = arbitrage_amount;
        uint256 Wa = ICatalystV1Vault(vault1)._weight(source_token);
        uint256 Wb = ICatalystV1Vault(vault2)._weight(target_token);
        uint256 arb_back_amount;
        if (amplified) {
            a *= Wa;
            b *= Wb;
            y *= Wb;
            int256 oneMinusAmp = CatalystVaultAmplified(vault1)._oneMinusAmp();
            console.log("hello1");
            int256 intermediate1 = FixedPointMathLib.powWad(int256(b * 10**18), oneMinusAmp - int256(FixedPointMathLib.WAD)) * int256(y) - FixedPointMathLib.powWad(int256(b * 10**18), oneMinusAmp);
            console.log("hello2");
            int256 intermediate2 = FixedPointMathLib.powWad(int256(b * 10**18 / (b - y)), int256(FixedPointMathLib.WAD) - oneMinusAmp);
            console.log("hello3");
            int256 intermediate3 = FixedPointMathLib.powWad(int256(a * 10**18), oneMinusAmp) + FixedPointMathLib.powWad(int256(b * 10**18), oneMinusAmp);
            console.log("hello4");
            arb_back_amount = (uint256(FixedPointMathLib.powWad(intermediate1 * intermediate2 / int256(FixedPointMathLib.WAD) + intermediate3, int256(10**18 * 10**18) / oneMinusAmp))/FixedPointMathLib.WAD - a) / Wa;
            console.log("hello5");
        } else {
            arb_back_amount = a * uint256(FixedPointMathLib.powWad(
                int256((b - y) * FixedPointMathLib.WAD / b),
                -1 * int256(Wb * FixedPointMathLib.WAD / Wa)
            ) - int256(FixedPointMathLib.WAD)) /FixedPointMathLib.WAD;
        }

        // Check that the user has the amount. Otherwise, just use the user's full amount.
        uint256 userBalance = Token(target_token).balanceOf(toAccount);
        if (userBalance < arb_back_amount) arb_back_amount = userBalance;

        vm.prank(toAccount);
        Token(target_token).approve(vault2, arb_back_amount);

        vm.recordLogs();
        vm.prank(toAccount);
        ICatalystV1Vault(vault2).sendAsset{value: _getTotalIncentive(_INCENTIVE)}(
            routeDescription,
            target_token,
            0,
            arb_back_amount,
            0,
            toAccount,
            1,
            hex""
        );
        entries = vm.getRecordedLogs();

        (, , messageWithContext) = abi.decode(entries[1].data, (bytes32, bytes, bytes));

        (_metadata, toExecuteMessage) = getVerifiedMessage(address(GARP), messageWithContext);

        // Process message
        vm.recordLogs();
        GARP.processPacket(_metadata, toExecuteMessage, FEE_RECIPITANT);

        entries = vm.getRecordedLogs();
        (, , messageWithContext) = abi.decode(entries[3].data, (bytes32, bytes, bytes));

        (_metadata, toExecuteMessage) = getVerifiedMessage(address(GARP), messageWithContext);

        // Process ack
        vm.recordLogs();
        GARP.processPacket(_metadata, toExecuteMessage, FEE_RECIPITANT);
        for (uint256 i = 0; i < 3; ++i) {
            address tkn = ICatalystV1Vault(vault1)._tokenIndexing(i);
            if (tkn == address(0)) break;
            assertEq(ICatalystV1Vault(vault2)._escrowedTokens(tkn), 0, "Ack didn't execute properly");
        }

        uint256 end_invariant = invariant(vaults);

        // Allow a very small difference.
        assertLe(start_invariant * (MARGIN_DENOM - MARGIN_NUM) / MARGIN_DENOM, end_invariant, "Invariant dropped beyond allowed");
    }
}

