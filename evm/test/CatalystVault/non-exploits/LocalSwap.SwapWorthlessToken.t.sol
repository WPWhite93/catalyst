// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "src/ICatalystV1Vault.sol";
import "solmate/utils/FixedPointMathLib.sol";
import {Token} from "../../mocks/token.sol";
import {AVaultInterfaces} from "../AVaultInterfaces.t.sol";

abstract contract TestSwapWorthlessTokenLocal is Test, AVaultInterfaces {
    function test_no_explit_localswap_worthless_token(uint56 amount) external {
        address[] memory vaults = getTestConfig();

        address worthless_token = address(new Token("Worthless", "WTL", 18, 1e6));

        for (uint256 i = 0; i < vaults.length; ++i) {
            address vault = vaults[i];
            ICatalystV1Vault v = ICatalystV1Vault(vault);

            // Send some of the worthless token to the vault to make sure that any calculations that takes
            // into account the current vault asset balance of the token doesn't fail
            Token(worthless_token).transfer(vault, 10**18);

            address toToken = v._tokenIndexing(0);
            uint256 initialBalance = Token(toToken).balanceOf(address(this));
            
            Token(worthless_token).approve(vault, amount);

            // amplified pools revert while volatile doesn't.
            if (amplified) {
                vm.expectRevert(bytes("UNDEFINED"));
                v.localSwap(worthless_token, toToken, amount, 0);
            } else {
                v.localSwap(worthless_token, toToken, amount, 0);
            }

            assertEq(
                Token(toToken).balanceOf(address(this)),
                initialBalance,
                "Pool exploited"
            );
        }
    }
}

